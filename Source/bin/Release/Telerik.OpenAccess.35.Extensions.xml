<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Telerik.OpenAccess.35.Extensions</name>
    </assembly>
    <members>
        <member name="T:Telerik.OpenAccess.FetchOptimization.FetchDefinition">
            <summary>The object that summarizes how an entity should be fetched. The FetchDefinition contains a collection of fetch members to specify fields which are retrieved together if the fetch definition is part of the actual FetchStrategy configuration.</summary>
        </member>
        <member name="T:Telerik.OpenAccess.FetchOptimization.IFetchDefinition`2">
            <summary>
            Represents an object that summarizes how an entity should be fetched.
            </summary>
            <typeparam name="T">Type of the meta type for which the IFetchDefinition is specified.</typeparam>
            <typeparam name="V">Type of the FetchStrategy which contains the IFetchDefinition.</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy`2">
            <summary>
            Represents a hierarchical object which can handle metadata resolution.
            </summary>
            <typeparam name="T">Type of the MetaItem for which metadata can be resolved.</typeparam>
            <typeparam name="V">Type of the parent object which contains the IFetchHierarchy.</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy">
            <summary>
            Represents a hierarchical object which can handle metadata resolution.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy.ResolveMetadata">
            <summary>
            Resolves metadata into an object.
            </summary>
            <returns>The resolved object.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy.ResolveMetadata(System.String)">
            <summary>
            Resolves a metadata name into an object.
            </summary>
            <param name="metadataName">The object name for which to resolve metadata.</param>
            <returns>An object corresponding to the metadata name.</returns>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy.FetchParent">
            <summary>
            Gets the parent object which contains the IFetchHierarchy.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy`2.ResolveMetadata">
            <summary>
            Resolves metadata into a MetaItem of type T.
            </summary>
            <returns>The resolved MetaItem of type T.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy`2.ResolveMetadata(System.String)">
            <summary>
            Resolves a metadata name into a MetaItem of type T.
            </summary>
            <param name="metadataName">The MetaItem name for which to resolve metadata.</param>
            <returns>A MetaItem of type T corresponding to the metadata name.</returns>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchHierarchy`2.FetchParent">
            <summary>
            Gets the parent object which contains the IFetchHierarchy.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchDefinition`2.RecursionDepth">
            <summary>
            Gets or sets the maximum number of same-typed relations to eager-fetch with the entity fetch definition. 
            For example, consider an Employee class with a manager field, also of type Employee. When we load an Employee and the manager field is part of the fetch definition, the recursion depth determines whether we only retrieve the target Employee and his manager (depth 1), or whether we also retrieve the manager's manager (depth 2), or the manager's manager's manager (depth 3), etc.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchDefinition`2.MetaType">
            <summary>
            Gets the MetaType for which the IFetchDefinition is specified.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchDefinition.#ctor(System.String)">
            <summary>Initializes a new instance of the FetchDefinition class.</summary>
            <param name="declaringTypeFullName">The full name of the type for which the definition is specified.</param>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchDefinition.#ctor(Telerik.OpenAccess.FetchOptimization.FetchStrategy,System.String)">
            <summary>Initializes a new instance of the FetchDefinition class.</summary>
            <param name="parent">The FetchStrategy which contains the FetchDefinition.</param>
            <param name="declaringTypeFullName">Full name of the type for which the definition is specified.</param>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchDefinition.#ctor(Telerik.OpenAccess.FetchOptimization.FetchStrategy,Telerik.OpenAccess.Metadata.MetaPersistentType)">
            <summary>Initializes a new instance of the FetchDefinition class.</summary>
            <param name="parent">The FetchStrategy which contains the FetchDefinition.</param>
            <param name="cachedMetaType">MetaPersistentType for which the definition is specified.</param>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchDefinition.#ctor(Telerik.OpenAccess.FetchOptimization.FetchStrategy)">
            <summary>Initializes a new instance of the FetchDefinition class.<!--DXMETADATA end --></summary>
            <param name="parent">The FetchStrategy which contains the FetchDefinition.</param>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchDefinition.ResolveMetadata(System.String)">
            <summary>Resolves a metadata name into a MetaPersistentType.</summary>
            <param name="metadataName">The MetaPersistentType name for which to resolve metadata.</param>
            <returns>A MetaPersistentType corresponding to the metadata name.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchDefinition.ResolveMetadata">
            <summary>Resolves metadata into a MetaPersistentType for which the FetchDefinition is specified.</summary>
            <returns>The resolved MetaPersistentType for which the FetchDefinition is specified.</returns>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchDefinition.RecursionDepth">
            <summary>Gets or sets the maximum number of same-typed relations to eager-fetch with the entity fetch definition. 
            For example, consider an Employee class with a manager field, also of type Employee. When we load an Employee and the manager field is part of the fetch definition, the recursion depth determines whether we only retrieve the target Employee and his manager (depth 1), or whether we also retrieve the manager's manager (depth 2), or the manager's manager's manager (depth 3), etc.</summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchDefinition.IsEmpty">
            <summary>Gets a value that indicates whether the FetchDefinition is empty.</summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchDefinition.Paths">
            <summary>
            
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchDefinition.Includes">
            <summary>
            
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchDefinition.FetchCriteria">
            <summary>
            
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchDefinition.MetaType">
            <summary>Gets the MetaPersistentType for which the FetchDefinition is specified.</summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchDefinition.FetchParent">
            <summary>Gets the FetchStrategy which contains the FetchDefinition. A FetchStrategy has one FetchDefinition per persistent type.</summary>
        </member>
        <member name="T:Telerik.OpenAccess.FetchOptimization.FetchMember">
            <summary>Specifies a field or a property as part of a FetchDefinition. A FetchDefiniton is a set of fields or properties belonging to one entity which are retrieved together when the FetchDefinition is contained in the actual FetchStrategy configuration.</summary>
        </member>
        <member name="T:Telerik.OpenAccess.FetchOptimization.IFetchMember`2">
            <summary>
            Represents a field or a property to be loaded with a related persistent type for which an IFetchDefinition is specified.
            </summary>
            <typeparam name="T">Type of the MetaMember encapsulating the field or proeprty to be loaded with a related persistent type.</typeparam>
            <typeparam name="V">Type of the FetchDifintion which includes the IFetchMember.</typeparam>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchMember`2.MetaMember">
            <summary>
            Gets the MetaMember which holds information about a field or a property of a persistent class.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchMember.#ctor(Telerik.OpenAccess.FetchOptimization.FetchDefinition,System.String)">
            <summary>Initializes a new instance of the FetchMember class.</summary>
            <param name="parent">A FetchDefinition that the FetchMember is part of.</param>
            <param name="metaMemberName">Name of the MetaMember which holds information about a field or a property of a persistent class</param>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchMember.#ctor(Telerik.OpenAccess.FetchOptimization.FetchDefinition,Telerik.OpenAccess.Metadata.MetaMember)">
            <summary>Initializes a new instance of the FetchMember class.</summary>
            <param name="parent">A FetchDefinition that the FetchMember is part of.</param>
            <param name="cachedMember">MetaMember which holds information about a field or a property of a persistent class</param>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchMember.#ctor(Telerik.OpenAccess.FetchOptimization.FetchDefinition)">
            <summary>Initializes a new instance of the FetchMember class.</summary>
            <param name="parent">A FetchDefinition that the FetchMember is part of.</param>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchMember.ResolveMetadata(System.String)">
            <summary>Resolves a metadata name into a MetaMember.</summary>
            <param name="metadataName">The MetaMember name for which to resolve metadata.</param>
            <returns>A MetaMember corresponding to the metadata name.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchMember.Telerik#OpenAccess#FetchOptimization#IFetchHierarchy#ResolveMetadata(System.String)">
            <summary>
            
            </summary>
            <param name="metadataName"></param>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchMember.ResolveMetadata">
            <summary>Resolves metadata into a MetaMember which holds information about a field or a property of a persistent class.</summary>
            <returns>The resolved MetaMember which holds information about a field or a property of a persistent class.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchMember.Telerik#OpenAccess#FetchOptimization#IFetchHierarchy#ResolveMetadata">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchMember.MetaMember">
            <summary>Gets the MetaMember which holds information about a field or a property of a persistent class.</summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchMember.FetchParent">
            <summary>Gets the FetchDefinition that the FetchMember is part of.</summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchMember.Telerik#OpenAccess#FetchOptimization#IFetchHierarchy#FetchParent">
            <summary>
            
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.FetchOptimization.FetchStrategy">
            <summary>Provides for immediate loading and filtering of related data.</summary>
            <example>
            In the following example, all the Orders for all the Customers from USA are retrieved when the query is executed. As a result, successive access to the Orders property on a Customer object does not trigger a new database query.
            <code title="Example1" description="" lang="C#">NorthwindDataContext db = new NorthwindDataContext();
            FetchStrategy fetchStrategy = new FetchStrategy();
            fetchStrategy.LoadWith&lt;Customer&gt;(c =&gt; c.Orders);
            db.FetchStrategy = fetchStrategy;
            var customerQuery =
                from customer in db.Customers
                where customer.Country == "USA"
                select customer;
            foreach (Customer custObj in customerQuery)
            {
                Console.WriteLine("Customer ID: {0}", custObj.CustomerID);
                foreach (Order order in custObj.Orders)
                {
                    Console.WriteLine("\tOrder ID: {0}", order.OrderID);
                }
            }</code><code title="Example1" description="" lang="VB.NET">Dim db As NorthwindDataContext = New NorthwindDataContext()
            Dim fetchStrategy As FetchStrategy = New FetchStrategy()
            fetchStrategy.LoadWith(Of Customer)(c =&gt; c.Orders)
            db.FetchStrategy = fetchStrategy
            Dim customerQuery = 
            	From customer In db.Customers 
            	Where customer.Country = "USA" 
            	Select customer
            For Each custObj As Customer In customerQuery
            	Console.WriteLine("Customer ID: {0}", custObj.CustomerID)
            	For Each order As Order In custObj.Orders
            		Console.WriteLine(Constants.vbTab &amp; "Order ID: {0}", order.OrderID)
            	Next order
            Next custObj</code></example>
        </member>
        <member name="T:Telerik.OpenAccess.FetchOptimization.IFetchStrategy`2">
            <summary>
            Represents a fetch strategy for immediate loading and filtering of related data.
            </summary>
            <typeparam name="T">Type of the meta model that inherits from MetadataContanier.</typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchStrategy`2.MaxFetchDepth">
            <summary>
            Gets or sets tha maximum fetch depth.
            The MaxFetchDepth determines how "deep" into the object graph to traverse when loading an instance.
            For example, with a MaxFetchDepth of 2, OpenAccess will load at most the target instance and its immediate relations. With a MaxFetchDepth of 3, OpenAccess may load the target instance, its immediate relations, and the relations of those relations.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchStrategy`2.MaxResultsLimit">
            <summary>
            Limits the maximum number of instances to return by query execution.
            </summary>
            <remarks>This property can be used for performance optimizations, if not all instances matching the query are required.</remarks>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.IFetchStrategy`2.MetaModel">
            <summary>
            Gets the MetaModel for which the loading options are specified. 
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.Freeze(Telerik.OpenAccess.Metadata.MetadataContainer)">
            <summary>
            Freezes the FetchStrategy to disallow addition of fetch definitons after the strategy has been assigned to an OpenAccessContext.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.UnFreeze">
            <summary>
            Unfreezes the FetchStrategy to allow addition of fetch definitons to the FetchStrategy.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.LoadWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>Specifies which sub-objects to retrieve when a query is submitted for an object of type T.</summary>
            <typeparam name="T">Type that is queried against.</typeparam>
            <param name="expression">Identifies the field or property to be retrieved.The expression should identify a field or property that represents a one-to-one or one-to-many
            relationship. The expression is of type &lt;Type&gt; =&gt; &lt;Type&gt;.&lt;Member&gt;.</param>
            <remarks>You cannot specify the loading of two levels of relationships (for example, Orders.OrderDetails). In these scenarios you must specify two separate LoadWith  methods.</remarks>
            <example>
            In the following example, all the Orders for all the Customers from USA are retrieved when the query is executed. As a result, successive access to the Orders property on a Customer object does not trigger a new database query.
            <code title="Example1" description="" lang="C#">NorthwindDataContext db = new NorthwindDataContext();
            FetchStrategy fetchStrategy = new FetchStrategy();
            fetchStrategy.LoadWith&lt;Customer&gt;(c =&gt; c.Orders);
            db.FetchStrategy = fetchStrategy;
            var customerQuery =
                from customer in db.Customers
                where customer.Country == "USA"
                select customer;
            foreach (Customer custObj in customerQuery)
            {
                Console.WriteLine("Customer ID: {0}", custObj.CustomerID);
                foreach (Order order in custObj.Orders)
                {
                    Console.WriteLine("\tOrder ID: {0}", order.OrderID);
                }
            }</code><code title="Example1" description="" lang="VB.NET">Dim db As NorthwindDataContext = New NorthwindDataContext()
            Dim fetchStrategy As FetchStrategy = New FetchStrategy()
            fetchStrategy.LoadWith(Of Customer)(c =&gt; c.Orders)
            db.FetchStrategy = fetchStrategy
            Dim customerQuery = 
            	From customer In db.Customers 
            	Where customer.Country = "USA" 
            	Select customer
            For Each custObj As Customer In customerQuery
            	Console.WriteLine("Customer ID: {0}", custObj.CustomerID)
            	For Each order As Order In custObj.Orders
            		Console.WriteLine(Constants.vbTab &amp; "Order ID: {0}", order.OrderID)
            	Next order
            Next custObj</code></example>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.LoadWith(System.Linq.Expressions.LambdaExpression)">
            <summary>Retrieves specified data related to the main target by using a lambda expression.</summary>
            <param name="expression">A lambda expression that identifies the related material.</param>
            <remarks>You cannot specify the loading of two levels of relationships (for example, Orders.OrderDetails). In these scenarios you must specify two
            separate LoadWith  methods or use the overload LoadWith&lt;T&gt;(params Expression&lt;Func&lt;T, object&gt;&gt;[] args).</remarks>
            <example>
            In the following example, all the Orders for all the Customers from USA are retrieved when the query is executed. As a result, successive access
            to the Orders property on a Customer object does not trigger a new database query.
            <code title="Example1" description="" lang="CS">NorthwindDataContext db = new NorthwindDataContext();
            FetchStrategy fetchStrategy = new FetchStrategy();
            fetchStrategy.LoadWith((Customer c) =&gt; c.Orders);
            db.FetchStrategy = fetchStrategy;
            var customerQuery =
                from customer in db.Customers
                where customer.Country == "USA"
                select customer;
            foreach (Customer custObj in customerQuery)
            {
                Console.WriteLine("Customer ID: {0}", custObj.CustomerID);
                foreach (Order order in custObj.Orders)
                {
                    Console.WriteLine("\tOrder ID: {0}", order.OrderID);
                }
            }</code><code title="Example1" description="" lang="VB.NET">Dim db As NorthwindDataContext = New NorthwindDataContext()
            Dim fetchStrategy As FetchStrategy = New FetchStrategy()
            fetchStrategy.LoadWith((Customer c) =&gt; c.Orders)
            db.FetchStrategy = fetchStrategy
            Dim customerQuery = 
            	From customer In db.Customers 
            	Where customer.Country = "USA" 
            	Select customer
            For Each custObj As Customer In customerQuery
            	Console.WriteLine("Customer ID: {0}", custObj.CustomerID)
            	For Each order As Order In custObj.Orders
            		Console.WriteLine(Constants.vbTab &amp; "Order ID: {0}", order.OrderID)
            	Next order
            Next custObj</code></example>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.LoadWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>Specifies which sub-objects to retrieve by using a variable number of expressions.</summary>
            <typeparam name="T">Type that is queried against.</typeparam>
            <param name="args">A variable number of expressions that identify the fields or properties to be retrieved. The expressions should identify fields or properties that represent one-to-one or one-to-many relationships.</param>
            <example>
            In the follwoing example the Supplier and Category for all the Products are loaded. As a result, successive access to the Supplier or Category
            property on a Product object does not trigger a new database query.
            <code title="Example1" description="" lang="CS">NorthwindDataContext db = new NorthwindDataContext();
            FetchStrategy fetchStrategy = new FetchStrategy();
            fetchStrategy.LoadWith&lt;Product&gt;(p =&gt; p.Category, p =&gt; p.Category);
            db.FetchStrategy = fetchStrategy;
            foreach (Product p in db.Products)
            {
               Console.WriteLine("Product ID: {0}", p.ProductID);
               Console.WriteLine("\tSupplier's Company Name: {0}", p.Supplier.CompanyName);
               Console.WriteLine("\tCategory Name: {0}", p.Category.CategoryName);
            }</code><code title="Example1" description="" lang="VB.NET">Dim db As New NorthwindDataContext()
            Dim fetchStrategy As New FetchStrategy()
            fetchStrategy.LoadWith(Of Product)(Function(p) p.Category, Function(p) p.Category)
            db.FetchStrategy = fetchStrategy
            For Each p As Product In db.Products
            	Console.WriteLine("Product ID: {0}", p.ProductID)
            	Console.WriteLine(vbTab &amp; "Supplier's Company Name: {0}", p.Supplier.CompanyName)
            	Console.WriteLine(vbTab &amp; "Category Name: {0}", p.Category.CategoryName)
            Next</code></example>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.LoadWith(System.Linq.Expressions.LambdaExpression[])">
            <summary>Retrieves specified data related to the main target by using a variable number of lambda expressions.</summary>
            <param name="args">A variable number of lambda expressions that identify the related material.</param>
            <example>
            In the follwoing example the Supplier and Category for all the Products are loaded. As a result, successive access to the Supplier or Category
            property on a Product object does not trigger a new database query.
            <code title="Example1" description="" lang="CS">NorthwindDataContext db = new NorthwindDataContext();
            FetchStrategy fetchStrategy = new FetchStrategy();
            fetchStrategy.LoadWith((Product p) =&gt; p.Category, (Product p) =&gt; p.Category);
            db.FetchStrategy = fetchStrategy;
            foreach (Product p in db.Products)
            {
               Console.WriteLine("Product ID: {0}", p.ProductID);
               Console.WriteLine("\tSupplier's Company Name: {0}", p.Supplier.CompanyName);
               Console.WriteLine("\tCategory Name: {0}", p.Category.CategoryName);
            }</code><code title="Example1" description="" lang="VB.NET">Dim db As New NorthwindDataContext()
            Dim fetchStrategy As New FetchStrategy()
            fetchStrategy.LoadWith(Function(p As Product) p.Category, Function(p As Product) p.Category)
            db.FetchStrategy = fetchStrategy
            For Each p As Product In db.Products
            	Console.WriteLine("Product ID: {0}", p.ProductID)
            	Console.WriteLine(vbTab &amp; "Supplier's Company Name: {0}", p.Supplier.CompanyName)
            	Console.WriteLine(vbTab &amp; "Category Name: {0}", p.Category.CategoryName)
            Next</code></example>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.ResolveMetadata">
            <summary>Resolves metadata into a MetadataContainer for which the load options are specified.</summary>
            <returns>The resolved MetadataContainer for which the load options are specified.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.FetchOptimization.FetchStrategy.ResolveMetadata(System.String)">
            <summary>Resolves a metadata name into a MetadataContainer.</summary>
            <param name="metadataName">The MetadataContainer name for which to resolve metadata.</param>
            <returns>A MetadataContainer corresponding to the metadata name.</returns>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchStrategy.MaxFetchDepth">
            <summary>Gets or sets tha maximum fetch depth.
            The MaxFetchDepth determines how "deep" into the object graph to traverse when loading an instance.
            For example, with a MaxFetchDepth of 2, OpenAccess will load at most the target instance and its immediate relations. With a MaxFetchDepth of 3, OpenAccess may load the target instance, its immediate relations, and the relations of those relations.</summary>
            <remarks>The value must be &gt;=1 and the default one is 3. The maximum possible value depends on the database server and the class hierarchy depth and is bound by the number of SQL joins required.</remarks>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchStrategy.MaxResultsLimit">
            <summary>Limits the maximum number of instances to return by query execution.</summary>
            <remarks>This property can be used for performance optimizations, if not all instances matching the query are required.</remarks>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchStrategy.IsFrozen">
            <summary>
            Gets a value that indicates whether the FetchStrategy is frozen.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchStrategy.IsEmpty">
            <summary>
            Gets a value that indicates whether the FetchStrategy is empty.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchStrategy.MetaModel">
            <summary>Gets the MetadataContainer for which the load options are specified.</summary>
        </member>
        <member name="P:Telerik.OpenAccess.FetchOptimization.FetchStrategy.FetchParent">
            <summary>Gets the parent containing the FetchStrategy.</summary>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.PropertyConfiguration">
            <summary>
            Base class for property configuration objects.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PropertyConfiguration.#ctor(Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration)">
            <summary>
            Base constructor accepting a mapping configuration object.
            </summary>
            <param name="mappingConfiguration">The mapping configuration object this object relates to.</param>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.BasicPropertyConfiguration">
            <summary>
            Serves as a base class for primitive and navigation properties of a mapping configuration object.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.BasicPropertyConfiguration.CreateColumn(Telerik.OpenAccess.Metadata.Relational.MetaTable)">
            <summary>
            Creates a MetaColumn instance based on the specified table.
            </summary>
            <param name="table">The table this column will refer to.</param>
            <returns>A MetaColumn instance.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.BasicPropertyConfiguration.SetPrimitiveMemberProperties(Telerik.OpenAccess.Metadata.MetaPrimitiveMember)">
            <summary>
            Sets the primitive member properties based on the specified primitive member.
            </summary>
            <param name="primitiveMember">The primitive member used to specify the properties.</param>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.EntityMap">
            <summary>
            Represents an object containing mapping configuration settings.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.EntityMap.ToTable(Telerik.OpenAccess.Metadata.Fluent.TableName)">
            <summary>
            Specifies the table name for this mapping configuration.
            </summary>
            <param name="tableName"></param>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.EntityMap.TableName">
            <summary>
            Gets the object that represents the table name for this mapping configuration.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.FluentMappingContext">
            <summary>
            Represents a base context class for fluent mapping scenarios.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.OpenAccessContext">
            <summary>
            OpenAccess context class for .NET 3.5 usage.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.OpenAccessContext.#ctor(System.String,Telerik.OpenAccess.BackendConfiguration,Telerik.OpenAccess.Metadata.MetadataSource)">
            <summary>
            OpenAccessContext Constructor with MetadataSource
            </summary>
            <param name="connectionString">The connection string name or the connection string. This is a required parameter</param>
            <param name="backendConfiguration">
            A backend configuration instance. If the parameter is null the default settings are used.
            For some backends the backend type cannot be derived from the connection string, the backend type must be set.
            </param>
            <param name="metadataSource">A metadata source. If non is specified the metadata is derived from the context itself.</param>
        </member>
        <member name="M:Telerik.OpenAccess.OpenAccessContext.#ctor(System.String,Telerik.OpenAccess.BackendConfiguration,Telerik.OpenAccess.Metadata.MetadataContainer)">
            <summary>
            OpenAccessContext Constructor with MetadataContainer
            </summary>
            <param name="connectionString">The connection string name or the connection string. This is a required parameter</param>
            <param name="backendConfiguration">
            A backend configuration instance. If the parameter is null the default settings are used.
            For some backends the backend type cannot be derived from the connection string. The backend type must be set then.
            </param>
            <param name="metadataContainer">A metadata container. If non is specified the metadata is derived from the context itself.</param>
        </member>
        <member name="M:Telerik.OpenAccess.OpenAccessContext.#ctor(System.String,Telerik.OpenAccess.BackendConfiguration,Telerik.OpenAccess.Metadata.MetadataContainer,System.Reflection.Assembly)">
            <summary>
            OpenAccessContext Constructor with MetadataContainer
            </summary>
            <param name="connectionString">The connection string name or the connection string. This is a required parameter</param>
            <param name="backendConfiguration">
            A backend configuration instance. If the parameter is null the default settings are used.
            For some backends the backend type cannot be derived from the connection string. The backend type must be set then.
            </param>
            <param name="metadataContainer">A metadata container. If non is specified the metadata is derived from the context itself.</param>
            <param name="callingAssembly">The assembly to search for the attribute mapping if no metadata is specified.</param>
        </member>
        <member name="M:Telerik.OpenAccess.OpenAccessContext.#ctor(System.String,Telerik.OpenAccess.BackendConfiguration,Telerik.OpenAccess.Metadata.MetadataSource,System.Reflection.Assembly)">
            <summary>
            OpenAccessContext Constructor with MetadataSource
            </summary>
            <param name="connectionString">The connection string name or the connection string. This is a required parameter</param>
            <param name="backendConfiguration">
            A backend configuration instance. If the parameter is null the default settings are used.
            For some backends the backend type cannot be derived from the connection string. The backend type must be set then.
            </param>
            <param name="metadataSource">A metadata source. If non is specified the metadata is derived from the context itself.</param>
            <param name="callingAssembly">The assembly to search for the attribute mapping if no metadata is specified.</param>
        </member>
        <member name="M:Telerik.OpenAccess.OpenAccessContext.#ctor(Telerik.OpenAccess.OpenAccessContextBase)">
            <summary>
            Copy constructor, the same database connection and configuration will be used.
            </summary>
            <param name="otherContext">An existing not disposed context</param>
        </member>
        <member name="M:Telerik.OpenAccess.OpenAccessContext.GetAll``1">
            <summary>
            Provides an IQueryable instance usable for Linq queries.
            </summary>
            <remarks>
            This is the main entry point for constructing LINQ queries with OpenAccess.
            </remarks>
            <typeparam name="T">The type of the persistent objects that should be queried.</typeparam>
            <returns>IQueryable instance that can be used to express queries.</returns>
            <seealso cref="F:ExtensionMethods.Matches"/>
        </member>
        <member name="P:Telerik.OpenAccess.OpenAccessContext.FetchStrategy">
            <summary>
            Controls the fetch strategy for this context.
            </summary>
            <remarks>
            The fetch strategy allows to control the amount of data that is prefetched by execution
            of queries.
            </remarks>
            <value>Fetch strategy instance</value>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.FluentMappingContext.#ctor(System.String,Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource,Telerik.OpenAccess.BackendConfiguration)">
            <summary>
            Initializes a new instance of the FluentMappingContextClass.
            </summary>
            <param name="connectionString">The connection string name or the connection string. This is a required parameter</param>
            <param name="fluentMappingSource">The fluent metadata source that provides the metadata for the current context.</param>
            <param name="backendConfiguration">
            A backend configuration instance. If the parameter is null the default settings are used.
            For some backends the backend type cannot be derived from the connection string, the backend type must be set.
            </param>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource">
            <summary>
            Represents a mapping source that uses fluent configuration to create the mapping model.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource.#ctor">
            <summary>
            Initializes a new instance of the FluentMappingSource class.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource.#ctor(Telerik.OpenAccess.Metadata.MetadataContainer)">
            <summary>
            Initializes a new instance of the FluentMappingSource class with an existing metadata container.
            </summary>
            <param name="existingContainer">An existing metadata container.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource.FromAssembly(System.Reflection.Assembly)">
            <summary>
            Creates a mapping source which contains the metadata for all of the persistent classes defined with fluent API in this assembly.
            </summary>
            <param name="assembly">A compiled assembly</param>
            <returns>The new Fluent mapping source as type FluentMappingSource</returns>
            <remarks>When creating a mapping source from an assembly, OpenAccess 
            behves like there is only one meta model inside that assembly. If you want to use multiple meta models in one assembly,
            use the FromContext implementation.</remarks>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource.PrepareMapping">
            <summary>
            Called when this context instance is initializing and a model needs to be obtained.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource.CreateModel">
            <summary>
            Creates a MetadataContainer instance using the list of mapping configurations.
            </summary>
            <returns>A MetadataContainer instance.</returns>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.FluentMetadataSource.MappingConfigurations">
            <summary>
            Gets the list of mapping configurations that will be used to create the mapping model.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration">
            <summary>
            Base class for mapping configurations.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration.GetPropertyInfoFromExpression(System.Linq.Expressions.Expression)">
            <summary>
            Gets a property info object from the specified expression.
            </summary>
            <param name="expression">The expression specifying the property.</param>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration.CreateFieldNamingRules">
            <summary>
            Creates default naming rules for the mapping configuration to use.
            </summary>
            <returns>A NamingRules instance.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration.GetConfiguredType">
            <summary>
            Gets the configured type.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration.DefaultMapProperties">
            <summary>
            Create default mapping for properties.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration.ProcessNewExpression(System.Linq.Expressions.NewExpression)">
            <summary>
            Process the specified expression that specifies property to column mapping.
            </summary>
            <param name="newExpression">The expression to be processed.</param>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration.FieldNamingRules">
            <summary>
            Gets or sets the naming rules used for deriving the field name for a property.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1">
            <summary>
            Represents the mapping configuration for a persistent type and its members.
            </summary>
            <typeparam name="TEntity">The persistent type to be mapped.</typeparam>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.MapSingleType">
            <summary>
            Specifies that all of the properties mapping should be handled by OpenAccess.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.MapSingleType(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specifies the property to column mapping for primitive members of the persistent type.
            </summary>
            <param name="propertyMap">An expression specifying the property to column mapping of the persistent type.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Association``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IList{``0}}})">
            <summary>
            Define the mapping for a collection property.
            </summary>
            <typeparam name="TInverse">The persistent type of the other end of the relation.</typeparam>
            <param name="expression">An expression specifying the collection property to be mapped.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Association``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Gets the configuration object for a navigation property.
            </summary>
            <typeparam name="TInverse">The persistent type of the other end of the relation.</typeparam>
            <param name="expression">An expression specifying the reference property to be mapped.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Gets the property configuration object for a property of type bool.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{System.Boolean}}})">
            <summary>
            Gets the property configuration object for a property of type nullable bool.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Int16}})">
            <summary>
            Gets the property configuration object for a property of type short.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{System.Int16}}})">
            <summary>
            Gets the property configuration object for a property of type short.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Int32}})">
            <summary>
            Gets the property configuration object for a property of type int .
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{System.Int32}}})">
            <summary>
            Gets the property configuration object for a property of type nullable int.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Int64}})">
            <summary>
            Gets the property configuration object for a property of type long .
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{System.Int64}}})">
            <summary>
            Gets the property configuration object for a property of type nullable long.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Single}})">
            <summary>
            Gets the property configuration object for a property of type float.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{System.Single}}})">
            <summary>
            Gets the property configuration object for a property of type nullable float.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Double}})">
            <summary>
            Gets the property configuration object for a property of type double.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{System.Double}}})">
            <summary>
            Gets the property configuration object for a property of type nullable double.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Guid}})">
            <summary>
            Gets the property configuration object for a property of type guid.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{System.Guid}}})">
            <summary>
            Gets the property configuration object for a property of type nullable guid.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.String}})">
            <summary>
            Gets the property configuration object for a property of type string.
            </summary>
            <param name="expression">An expression specifying the property</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration`1.GetConfiguredType">
            <summary>
            Gets the configured type.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.JoinTableConfiguration`2.GetConfiguredType">
            <summary>
            Gets the configured type instance.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.ArtificialNavigationPropertyConfiguration.IsDependent">
            <summary>
            Specifies that this navigation property is dependent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.ArtificialNavigationPropertyConfiguration.IsDependent(System.Boolean)">
            <summary>
            Specifies that this navigation property is dependent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.ArtificialNavigationPropertyConfiguration.IsManaged">
            <summary>
            Specifies that this navigation property is managed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.ArtificialNavigationPropertyConfiguration.IsManaged(System.Boolean)">
            <summary>
            Specifies that this navigation property is managed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.ArtificialNavigationPropertyConfiguration.IsRequired">
            <summary>
            Specifies that this navigation property requires a value.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2">
            <summary>
            Represents the configuration of a navigation property.
            </summary>
            <typeparam name="TEntity">The type that contains the navigation property.</typeparam>
            <typeparam name="TInverse">The type that the naviation property refers to.</typeparam>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.#ctor(Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration,Telerik.OpenAccess.Metadata.Fluent.PropertyInfo)">
            <summary>
            Initializes a new NavigationPropertyConfiguration instance.
            </summary>
            <param name="mappingConfiguration">The mapping configuration object that contains this object.</param>
            <param name="ownProperty">The property that specifies the start point of the relation.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.IsRequired">
            <summary>
            Specifies that this navigation property requires a value.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.IsDependent">
            <summary>
            Specifies that this navigation property is dependent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.IsDependent(System.Boolean)">
            <summary>
            Specifies that this navigation property is dependent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.IsManaged">
            <summary>
            Specifies that this navigation property is managed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.IsManaged(System.Boolean)">
            <summary>
            Specifies that this navigation property is managed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.FromInverse(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IList{`0}}})">
            <summary>
            Specifies the inverse property of the relation.
            </summary>
            <param name="expression">An expession specifying the inverse property of the relation that is a collection.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.FromInverse(System.Linq.Expressions.Expression{System.Func{`1,`0}})">
            <summary>
            Specifies the inverse property of the relation.
            </summary>
            <param name="expression">An expession specifying the inverse property of the relation that is a reference.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.HasConstraint(System.Linq.Expressions.Expression{System.Func{`0,`1,System.Boolean}})">
            <summary>
            Specifies the constraint that defines the relation and its endpoints.
            </summary>
            <param name="constraintExpression">Expression defining the constraint and endpoints for the relation</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.NavigationPropertyConfiguration`2.MapJoinTable(Telerik.OpenAccess.Metadata.Fluent.TableName,System.Linq.Expressions.Expression{System.Func{`0,`1,System.Object}})">
            <summary>
            Specifies the join table that defines a many to many relation and its endpoints.
            </summary>
            <param name="tableName">The name of the table.</param>
            <param name="joinTableMap">Expression specifying the join table and endpoints for the relation.</param>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.IdentityPropertyConfiguration">
            <summary>
            Represents the configuration for a property that can be an identity.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.IdentityPropertyConfiguration.#ctor(System.String,Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration)">
            <summary>
            Initializes a new instance of the IdentityPropertyConfiguration class.
            </summary>
            <param name="columnName">The name of the column.</param>
            <param name="mappingConfiguration">The mapping configuration object that constains this object.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.IdentityPropertyConfiguration.GetIsIdentity">
            <summary>
            Gets whether this property is an identity.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.IdentityPropertyConfiguration.SetIsIdentity">
            <summary>
            Sets that this property is an identity.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.IdentityPropertyConfiguration.SetIsIdentity(Telerik.OpenAccess.Metadata.KeyGenerator)">
            <summary>
            Sets that this property is an identity with the specified key generator.
            </summary>
            <param name="keyGenerator">A key generator.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.IdentityPropertyConfiguration.CreateColumn(Telerik.OpenAccess.Metadata.Relational.MetaTable)">
            <summary>
            Creates a MetaColumn instance based on the specified table.
            </summary>
            <param name="table">The table this column will refer to.</param>
            <returns>A MetaColumn instance.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.IdentityPropertyConfiguration.SetPrimitiveMemberProperties(Telerik.OpenAccess.Metadata.MetaPrimitiveMember)">
            <summary>
            Sets the primitive member properties based on the specified primitive member.
            </summary>
            <param name="primitiveMember">The primitive member used to specify the properties.</param>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration">
            <summary>
            Represents the configuration for a property of a value type.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.#ctor(Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration)">
            <summary>
            Initializes a new instance of the PrimitivePropertyConfiguration class.
            </summary>
            <param name="mappingConfiguration">The mapping configuration object that contains this object.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.#ctor(System.String,Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration)">
            <summary>
            Initializes a new instance of the PrimitivePropertyConfiguration class.
            </summary>
            <param name="columnName">The name of the column.</param>
            <param name="mappingConfiguration">The mapping configuration object that contains this object.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.SetFieldName(System.String)">
            <summary>
            Specify the field name that this property relates to.
            </summary>
            <param name="fieldName">The name of the field.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.SetColumnName(System.String)">
            <summary>
            Specify the column name that this property is mapped to.
            </summary>
            <param name="columnName">The name of the column.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.IsNullable">
            <summary>
            Specifies that the property is nullable.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.IsVersion">
            <summary>
            Specifies that the property contains information about versioning.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.IsIdentity">
            <summary>
            Specifies that the property is part of the identity key.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.IsIdentity(Telerik.OpenAccess.Metadata.KeyGenerator)">
            <summary>
            Specifies  that the property is part of the identity key.
            </summary>
            <param name="keyGenerator">The key generator used for this property.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.HasPrecision(System.Int32)">
            <summary>
            Specifies the precision of this property
            </summary>
            <param name="precision">The precision of the property.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.HasScale(System.Int32)">
            <summary>
            Specifies the scale of this property.
            </summary>
            <param name="scale">The scale of this property.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.CreateColumn(Telerik.OpenAccess.Metadata.Relational.MetaTable)">
            <summary>
            Creates a MetaColumn instance based on the specified table.
            </summary>
            <param name="table">The table this column will refer to.</param>
            <returns>A MetaColumn instance.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PrimitivePropertyConfiguration.SetPrimitiveMemberProperties(Telerik.OpenAccess.Metadata.MetaPrimitiveMember)">
            <summary>
            Sets the primitive member properties based on the specified primitive member.
            </summary>
            <param name="primitiveMember">The primitive member used to specify the properties.</param>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration">
            <summary>
            Represents the configuration for a property of type string.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration.#ctor(Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration)">
            <summary>
            Initializes a new StringPropertyConfiguration object.
            </summary>
            <param name="mappingConfiguration">The mapping configuration object that contains this object.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration.#ctor(System.String,Telerik.OpenAccess.Metadata.Fluent.MappingConfiguration)">
            <summary>
            Initializes a new StringPropertyConfiguration object.
            </summary>
            <param name="columnName">The name of the column.</param>
            <param name="mappingConfiguration">The mapping configuration object that contains this object.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration.IsIdentity">
            <summary>
            Specifies that the property is part of the identity key.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration.SetFieldName(System.String)">
            <summary>
            Specify the field name that this property relates to.
            </summary>
            <param name="fieldName">The name of the field.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration.SetColumnName(System.String)">
            <summary>
            Specify the column name that this property is mapped to.
            </summary>
            <param name="columnName">The name of the column.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration.HasLength(System.Int32)">
            <summary>
            Specifies the length of this string property.
            </summary>
            <param name="length">The length of this string property.</param>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.StringPropertyConfiguration.CreateColumn(Telerik.OpenAccess.Metadata.Relational.MetaTable)">
            <summary>
            Creates a MetaColumn instance based on the specified table.
            </summary>
            <param name="table">The table this column will refer to.</param>
            <returns>A MetaColumn instance.</returns>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo">
            <summary>
            Represents an object that contains information about properties of a mapped type.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.#ctor(System.String,System.Type,System.Type)">
            <summary>
            Initializes a new PropertyInfo object.
            </summary>
            <param name="name">Name of the property.</param>
            <param name="type">Type of the property.</param>
            <param name="declaringType">Type of the declaring type.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.Equals(Telerik.OpenAccess.Metadata.Fluent.PropertyInfo)">
            <summary>
            Determines whether the specified PropertyInfo object is equal to the current PropertyInfo Object.
            </summary>
            <param name="other">An object of type PropertyInfo</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.Equals(System.Object)">
            <summary>
            Determines whether the specified Object is equal to the current Object.
            </summary>
            <param name="obj">Object to compare.</param>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.PropertyName">
            <summary>
            Gets the property name.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.PropertyType">
            <summary>
            Gets the property type.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.DeclaringType">
            <summary>
            Gets the declaring property type.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.IsReference">
            <summary>
            Gets or sets whether this is a reference property.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.PropertyInfo.IsCollection">
            <summary>
            Gets or sets wheter this a collection property.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Metadata.Fluent.TableName">
            <summary>
            Represents the name of a table.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.TableName.#ctor(System.String,System.String)">
            <summary>
            Initializes a new TableName object.
            </summary>
            <param name="tableName">The name of the table.</param>
            <param name="schemaName">The schema of the table.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.TableName.op_Implicit(System.String)~Telerik.OpenAccess.Metadata.Fluent.TableName">
            <summary>
            Implicitly convert from a string property.
            </summary>
            <param name="tableName">The table name.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.TableName.FromString(System.String)">
            <summary>
            Create a new TableName object from a string.
            </summary>
            <param name="tableName">The table name.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Metadata.Fluent.TableName.ToString">
            <summary>
            Returns the full name of the table.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.TableName.ShortName">
            <summary>
            Gets the table name without the schema name.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.TableName.SchemaName">
            <summary>
            Gets the schema name.
            </summary>
        </member>
        <member name="P:Telerik.OpenAccess.Metadata.Fluent.TableName.FullName">
            <summary>
            Gets the full name of the table.
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.GetQueryExpression(IQToolkit.Data.Common.MappingEntity)">
            <summary>
            Get a query expression that selects all entities from a table
            </summary> 
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.GetEntityExpression(System.Linq.Expressions.Expression,IQToolkit.Data.Common.MappingEntity)">
            <summary>
            Gets an expression that constructs an entity instance relative to a root.
            The root is most often a TableExpression, but may be any other experssion such as
            a ConstantExpression.
            </summary>
            <param name="root"></param>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.GetMemberExpression(System.Linq.Expressions.Expression,IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Get an expression for a mapped property relative to a root expression. 
            The root is either a TableExpression or an expression defining an entity instance.
            </summary>
            <param name="root"></param>
            <param name="entity"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.GetInsertExpression(IQToolkit.Data.Common.MappingEntity,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Get an expression that represents the insert operation for the specified instance.
            </summary>
            <param name="entity"></param>
            <param name="instance">The instance to insert.</param>
            <param name="selector">A lambda expression that computes a return value from the operation.</param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.GetUpdateExpression(IQToolkit.Data.Common.MappingEntity,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
            <summary>
            Get an expression that represents the update operation for the specified instance.
            </summary>
            <param name="entity"></param>
            <param name="instance"></param>
            <param name="updateCheck"></param>
            <param name="selector"></param>
            <param name="else"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.GetInsertOrUpdateExpression(IQToolkit.Data.Common.MappingEntity,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Get an expression that represents the insert-or-update operation for the specified instance.
            </summary>
            <param name="entity"></param>
            <param name="instance"></param>
            <param name="updateCheck"></param>
            <param name="resultSelector"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.GetDeleteExpression(IQToolkit.Data.Common.MappingEntity,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Get an expression that represents the delete operation for the specified instance.
            </summary>
            <param name="entity"></param>
            <param name="instance"></param>
            <param name="deleteCheck"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.IncludeMembers(IQToolkit.Data.Common.EntityExpression,System.Func{System.Reflection.MemberInfo,System.Boolean})">
            <summary>
            Recreate the type projection with the additional members included
            </summary>
            <param name="entity"></param>
            <param name="fnIsIncluded"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.HasIncludedMembers(IQToolkit.Data.Common.EntityExpression)">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.ApplyMapping(System.Linq.Expressions.Expression)">
            <summary>
            Apply mapping to a sub query expression
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.IsParameterMethod(System.Linq.Expressions.Expression)">
            <summary>
            Tests if the given expression is a paramter to the query
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.IsProviderMethod(System.Linq.Expressions.Expression)">
            <summary>
            Tests if the given expression is the actual provider for the query
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapper.Translate(System.Linq.Expressions.Expression)">
            <summary>
            Apply mapping translations to this expression
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapper.GetColumnType(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            The query language specific type for the column
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.OpenAccessExecutionBuilder">
            <summary>
            Builds an execution plan for a query expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.DbExpressionVisitor">
            <summary>
            An extended expression visitor including custom DbExpression nodes
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.OpenAccessExecutionBuilder.OuterParameterizer">
            <summary>
            columns referencing the outer alias are turned into special named-value parameters
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.OpenAccessGrouping`2">
            <summary>
            Simple implementation of the IGrouping interface
            </summary>
            <typeparam name="TKey">Grouping key type</typeparam>
            <typeparam name="TElement">Grouped element type</typeparam>
        </member>
        <member name="T:IQToolkit.QueryProvider">
            <summary>
            A basic abstract LINQ query provider
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.IQueryText" -->
        <member name="M:Telerik.OpenAccess.Query.ExpressionWalker.CanBeEvaluatedLocally(System.Linq.Expressions.Expression)">
            <summary>
            Determines whether a given expression can be executed locally. 
            (It contains no parts that should be translated to the target environment.)
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ExpressionExecution">
            <summary>
            Execution methods for LINQ queries. 
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.PerformDatabaseQuery``1(Telerik.OpenAccess.Query.Piece{``0},System.Object[])">
            <summary>
            Main method to execute a query that should return multiple results.
            </summary>
            <typeparam name="T">Type of result elements</typeparam>
            <param name="piece">Last part of the LINQ expression chain</param>
            <param name="grpVals">When a grouping query is to be resolved, this are the grouping key values.</param>
            <returns>Result set iterator</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.PerformDatabaseQuerySingle``2(Telerik.OpenAccess.Query.Piece{``1},System.Int32@,System.Int32,System.Boolean)">
            <summary>
            Performs a database query that should return only one result.
            </summary>
            <typeparam name="TResult">Type of result</typeparam>
            <typeparam name="T">Type of last LINQ expression</typeparam>
            <param name="piece">Last LINQ expression</param>
            <param name="found">Number of results found</param>
            <param name="elemAt">Element position when >= 0; ignored otherwise</param>
            <param name="single">Indicates that Single or SingleOrDefault is to be executed</param>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.PerformQuerySingle``2(Telerik.OpenAccess.Query.Piece{``0},System.Linq.Expressions.Expression)">
            <summary>
            Performs a LINQ query that should return a single result.
            </summary>
            <typeparam name="T">Type of last LINQ expression piece</typeparam>
            <typeparam name="TResult">Result type</typeparam>
            <param name="piece">Last LINQ expression</param>
            <param name="expression">Expression that is causing the execution on top of the last LINQ expression</param>
            <returns>Result</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.PerformQueryCount``1(Telerik.OpenAccess.Query.Piece{``0})">
            <summary>
            Performs a database query to obtain the number of result elements.
            </summary>
            <typeparam name="T">Type of last LINQ expression piece</typeparam>
            <param name="piece">Last LINQ expression piece</param>
            <returns>Number of result elements as calculated by the database server</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.PerformQueryGroupResolve``2(Telerik.OpenAccess.Query.ExpressionCompiler,``1)">
            <summary>
            Resolves the IGroupable produced by this query for the given key.
            </summary>
            <typeparam name="TElement">Extent type (PC)</typeparam>
            <typeparam name="TKey">Grouping type (the key of the group)</typeparam>
            <param name="key">Group key value</param>
            <param name="origQuery">Original query (with grouping)</param>
            <returns>Enumerable of PC</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.PerformQueryCompilation``1(Telerik.OpenAccess.Query.Piece{``0})">
            <summary>
            Returns the backend query that would be used for exececution.
            </summary>
            <typeparam name="T">Type of last LINQ query expression</typeparam>
            <param name="piece">Last LINQ query expression</param>
            <returns>Relational backend query</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.CheckQueryPiece``2(Telerik.OpenAccess.Query.Piece{``0},Telerik.OpenAccess.Query.Piece{``1})">
            <summary>
            Checks the created piece if the resulting query can be run on the server or not.
            </summary>
            <typeparam name="TResult">Result element type</typeparam>
            <typeparam name="T">Existing, accepted query element type</typeparam>
            <param name="created">Newly created query piece</param>
            <param name="prev">Existing, accepted query epiece</param>
            <returns><c>Null</c> when the transition to in-memory-query has to be made</returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExpressionExecution.GetCategory(Telerik.OpenAccess.Query.QueryableToken,System.Linq.Expressions.Expression)">
            <summary>
            Classifies an expression with regard to its effects on a simple query.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.ExtensionMethods">
            <summary>
            Extension methods for Telerik.OpenAccess that provide the entries for LINQ.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.ExtensionMethods.Extent``1(Telerik.OpenAccess.IObjectScope)">
            <summary>
            Provides an IQueryable instance usable for Linq queries.
            </summary>
            <remarks>
            This is the main entry point for constructing LINQ queries with OpenAccess.
            </remarks>
            <param name="scope">The object scope this LINQ query is bound to</param>
            <typeparam name="T">The type of the persistent objects that should be queried.</typeparam>
            <returns>IQueryable instance that can be used to express queries.</returns>
            <seealso cref="M:Telerik.OpenAccess.ExtensionMethods.Matches(System.String,System.String)"/>
        </member>
        <member name="M:Telerik.OpenAccess.ExtensionMethods.Matches(System.String,System.String)">
            <summary>
            Returns true when the string matches a certain regular expression using * and ? wildcards.
            </summary>
            <remarks>
            This is a tagging method that will be translated into the correct SQL LIKE statements where
            the * and ? wildcards need to be translated into backend specific wildcards (typically % and _).
            You can escape the * and ? characters by prefixing them with a single backslash.
            </remarks>
            <param name="left">The string that should match the <paramref name="wildcardPattern">wildcard pattern</paramref>.</param>
            <param name="wildcardPattern">The wildcard pattern with the * and ? wildcards.</param>
            <returns><c>True</c> when a match is found.</returns>
        </member>
        <member name="M:Telerik.OpenAccess.ExtensionMethods.FieldValue``1(System.Object,System.String)">
            <summary>
            Returns the value of the named persistent field of the given persistent instance.
            </summary>
            <typeparam name="T">The type of the persistent field</typeparam>
            <param name="persistentInstance">The persistent instance whose field value is to be returned</param>
            <param name="nameOfPersistentField">The name of the persistent field whose value is to be returned</param>
            <returns>Value of the field</returns>
        </member>
        <member name="T:Telerik.OpenAccess.ExtentQuery`1">
            <summary>
            Represents a typed LINQ query in an OpenAccess context.
            </summary>
            <remarks>
            This interface allows to configure the dynamic behavior of a LINQ query.
            </remarks>
            <typeparam name="T">Type of the results set elements</typeparam>
        </member>
        <member name="M:Telerik.OpenAccess.ExtentQuery`1.ParallelFetch(System.Boolean)">
            <summary>
            Determines whether parallel result fetching is allowed.
            </summary>
            <remarks>
            Parallel fetching allow the efficient retrieval of a single collection field from the result set elements.
            </remarks>
            <param name="allowParallelFetch"><c>True</c> when parallel fetching is to be allowed (Default: False)</param>
            <returns>New query instance</returns>
        </member>
        <member name="M:Telerik.OpenAccess.ExtentQuery`1.IgnoreUncommitted(System.Boolean)">
            <summary>
            Determines whether the query execution is allowed to ignore the
            changes made in the current transaction.
            </summary>
            <remarks>
            When the query is set to not ignore uncommitted changes, the content of the current 
            transaction will be flushed (but not yet committed) to the database server. After that,
            objects deleted, changed or inserted in the current transaction will be visible to the
            query and the result will reflect the (uncommitted) changes.
            </remarks>
            <param name="doNotFlush"><c>True</c> when uncommitted changes are ignored. (Default: True)</param>
            <returns>New query instance</returns>
        </member>
        <member name="M:Telerik.OpenAccess.ExtentQuery`1.ForwardsOnly(System.Boolean)">
            <summary>
            Determines whether the query result can be traversed forwards only, or if random access is possible.
            </summary>
            <remarks>
            Normal LINQ applications rarely have the need to change the behavior to random access as LINQ queries
            tend to favor forward reading.
            </remarks>
            <param name="noRandomAccess"><c>True</c> when the result set is accessed in a forward iterating manner only. (Default: True></param>
            <returns>Query instance</returns>
        </member>
        <member name="M:Telerik.OpenAccess.ExtentQuery`1.Debug(System.Boolean)">
            <summary>
            Controls additional query tracing and execution debugging aids.
            </summary>
            <remarks>
            This method is for internal debugging methods only and should not be relied upon in production code.
            </remarks>
            <param name="show"><c>True</c> for additional information. (Default: False)</param>
            <returns>Query instance</returns>
        </member>
        <member name="T:Telerik.OpenAccess.Query.Piece`1">
            <summary>
            A LINQ query expression piece for OpenAccess.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ChainedContext">
            <summary>
            Base class of all queryable pieces that are given out to the LINQ user.
            </summary>
            <remarks>
            Exists to have a non-generic base class for easy handling.
            </remarks>
        </member>
        <member name="M:Telerik.OpenAccess.Query.Piece`1.ToString">
            <summary>
            Returns the SQL that is generated for query execution.
            </summary>
            <returns>SQL statement</returns>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ExecutionSettings">
            <summary>
            Provides the settings for the execution of a LINQ query.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Query.ExtentQueryImpl`1.ToString">
            <summary>
            Returns the SQL that is generated for query execution.
            </summary>
            <returns>SQL statement</returns>
        </member>
        <member name="F:Telerik.OpenAccess.Query.FormTreeDisplay.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Query.FormTreeDisplay.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Telerik.OpenAccess.Query.FormTreeDisplay.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ExecutionBuilder">
            <summary>
            Builds an execution plan for a query expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ExecutionBuilder.OuterParameterizer">
            <summary>
            columns referencing the outer alias are turned into special named-value parameters
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.Aggregator.GetAggregator(System.Type,System.Type)">
            <summary>
            Get a function that coerces a sequence of one type into another type.
            This is primarily used for aggregators stored in ProjectionExpression's, which are used to represent the 
            final transformation of the entire result set of a query.
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.DbExpressionComparer">
            <summary>
            Determines if two expressions are equivalent. Supports DbExpression nodes.
            </summary>
        </member>
        <member name="T:IQToolkit.ExpressionComparer">
            <summary>
            Compare two expressions to determine if they are equivalent
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.DbExpressionReplacer">
            <summary>
            Replaces references to one specific instance of an expression node with another node.
            Supports DbExpression nodes
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.DbExpressionType">
            <summary>
            Extended node types for custom expressions
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.TableExpression">
            <summary>
            A custom expression node that represents a table reference in a SQL query
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ColumnExpression">
            <summary>
            A custom expression node that represents a reference to a column in a SQL query
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ColumnDeclaration">
            <summary>
            A declaration of a column in a SQL SELECT expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.OrderType">
            <summary>
            An SQL OrderBy order type 
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.OrderExpression">
            <summary>
            A pairing of an expression and an order type for use in a SQL Order By clause
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.SelectExpression">
            <summary>
            A custom expression node used to represent a SQL SELECT expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.JoinType">
            <summary>
            A kind of SQL join
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.JoinExpression">
            <summary>
            A custom expression node representing a SQL join clause
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.IsNullExpression">
            <summary>
            Allows is-null tests against value-types like int and float
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ProjectionExpression">
            <summary>
            A custom expression representing the construction of one or more result objects from a 
            SQL select expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.DbExpressionWriter">
            <summary>
            Writes out an expression tree (including DbExpression nodes) in a C#-ish syntax
            </summary>
        </member>
        <member name="T:IQToolkit.ExpressionWriter">
            <summary>
            Writes out an expression tree in a C#-ish syntax
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.QueryLanguage">
            <summary>
            Defines the language rules for the query provider
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryLanguage.IsScalar(System.Type)">
            <summary>
            Determines whether the CLR type corresponds to a scalar data type in the query language
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryLanguage.CanBeColumn(System.Linq.Expressions.Expression)">
            <summary>
            Determines whether the given expression can be represented as a column in a select expressionss
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryLinguist.Translate(System.Linq.Expressions.Expression)">
            <summary>
            Provides language specific query translation.  Use this to apply language specific rewrites or
            to make assertions/validations about the query.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryLinguist.Format(System.Linq.Expressions.Expression)">
            <summary>
            Converts the query expression into text of this query language
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryLinguist.Parameterize(System.Linq.Expressions.Expression)">
            <summary>
            Determine which sub-expressions must be parameters
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:IQToolkit.Data.Common.SqlFormatter">
            <summary>
            Formats a query expression into common SQL language syntax
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.Data.Common.QueryMapping" -->
        <member name="M:IQToolkit.Data.Common.QueryMapping.GetTableId(System.Type)">
            <summary>
            Determines the entity Id based on the type of the entity alone
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapping.GetEntity(System.Type)">
            <summary>
            Get the meta entity directly corresponding to the CLR type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapping.GetEntity(System.Type,System.String)">
            <summary>
            Get the meta entity that maps between the CLR type 'entityType' and the database table, yet
            is represented publicly as 'elementType'.
            </summary>
            <param name="elementType"></param>
            <param name="entityID"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapping.GetEntity(System.Reflection.MemberInfo)">
            <summary>
            Get the meta entity represented by the IQueryable context member
            </summary>
            <param name="contextMember"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapping.IsRelationship(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if a property is mapped as a relationship
            </summary>
            <param name="entity"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapping.IsSingletonRelationship(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if a relationship property refers to a single entity (as opposed to a collection.)
            </summary>      
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryMapping.CanBeEvaluatedLocally(System.Linq.Expressions.Expression)">
            <summary>
            Determines whether a given expression can be executed locally. 
            (It contains no parts that should be translated to the target environment.)
            </summary>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.IsMapped(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Deterimines is a property is mapped onto a column or relationship
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.IsColumn(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if a property is mapped onto a column
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.GetColumnDbType(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            The type declaration for the column in the provider's syntax
            </summary>
            <param name="entity"></param>
            <param name="member"></param>
            <returns>a string representing the type declaration or null</returns>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.IsPrimaryKey(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if a property represents or is part of the entities unique identity (often primary key)
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.IsComputed(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if a property is computed after insert or update
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.IsGenerated(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if a property is generated on the server during insert
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.IsUpdatable(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if a property can be part of an update operation
            </summary>
            <param name="entity"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.GetRelatedEntity(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            The type of the entity on the other side of the relationship
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.IsAssociationRelationship(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if the property is an assocation relationship.
            </summary>
            <param name="entity"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.GetAssociationKeyMembers(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Returns the key members on this side of the association
            </summary>
            <param name="entity"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.GetAssociationRelatedKeyMembers(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Returns the key members on the other side (related side) of the association
            </summary>
            <param name="entity"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.GetTableName(IQToolkit.Data.Common.MappingEntity)">
            <summary>
            The name of the corresponding database table
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.GetColumnName(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            The name of the corresponding table column
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.BasicMapping.GetMappedMembers(IQToolkit.Data.Common.MappingEntity)">
            <summary>
            A sequence of all the mapped members
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.Data.Common.QueryPolicy" -->
        <member name="M:IQToolkit.Data.Common.QueryPolicy.IsIncluded(System.Reflection.MemberInfo)">
            <summary>
            Determines if a relationship property is to be included in the results of the query
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryPolicy.IsDeferLoaded(System.Reflection.MemberInfo)">
            <summary>
            Determines if a relationship property is included, but the query for the related data is 
            deferred until the property is first accessed.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryPolice.Translate(System.Linq.Expressions.Expression)">
            <summary>
            Provides policy specific query translations.  This is where choices about inclusion of related objects and how
            heirarchies are materialized affect the definition of the queries.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.Common.QueryPolice.BuildExecutionPlan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Converts a query into an execution plan.  The plan is an function that executes the query and builds the
            resulting objects.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.Data.Common.QueryTranslator" -->
        <member name="T:IQToolkit.Data.Common.AggregateChecker">
            <summary>
            Determines if a SelectExpression contains any aggregate expressions
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.AggregateRewriter">
            <summary>
            Rewrite aggregate expressions, moving them into same select expression that has the group-by clause
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ClientJoinedProjectionRewriter">
            <summary>
            rewrites nested projections into client-side joins
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ColumnMapper">
            <summary>
            Rewrite all column references to one or more aliases to a new single alias
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ProjectedColumns">
            <summary>
            Result from calling ColumnProjector.ProjectColumns
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ColumnProjector">
            <summary>
            Splits an expression into two parts
              1) a list of column declarations for sub-expressions that must be evaluated on the server
              2) a expression that describes how to combine/project the columns back together into the correct result
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ColumnProjector.Nominator">
            <summary>
            Nominator is a class that walks an expression tree bottom up, determining the set of 
            candidate expressions that are possible columns of a select expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.CrossApplyRewriter">
            <summary>
            Attempts to rewrite cross-apply and outer-apply joins as inner and left-outer joins
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.CrossJoinIsolator">
            <summary>
            Isolates cross joins from other types of joins using nested sub queries
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.CrossJoinRewriter">
            <summary>
            Attempt to rewrite cross joins as inner joins
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.DeclaredAliasGatherer">
            <summary>
             returns the set of all aliases produced by a query source
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.OrderByRewriter">
            <summary>
            Moves order-bys to the outermost select if possible
            </summary>
        </member>
        <member name="M:IQToolkit.Data.Common.OrderByRewriter.PrependOrderings(System.Collections.Generic.IList{IQToolkit.Data.Common.OrderExpression})">
            <summary>
            Add a sequence of order expressions to an accumulated list, prepending so as
            to give precedence to the new expressions over any previous expressions
            </summary>
            <param name="newOrderings"></param>
        </member>
        <member name="M:IQToolkit.Data.Common.OrderByRewriter.RebindOrderings(System.Collections.Generic.IEnumerable{IQToolkit.Data.Common.OrderExpression},IQToolkit.Data.Common.TableAlias,System.Collections.Generic.HashSet{IQToolkit.Data.Common.TableAlias},System.Collections.Generic.IEnumerable{IQToolkit.Data.Common.ColumnDeclaration})">
            <summary>
            Rebind order expressions to reference a new alias and add to column declarations if necessary
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.Parameterizer">
            <summary>
            Converts user arguments into named-value parameters
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.QueryBinder">
            <summary>
            Converts LINQ query operators to into custom DbExpression's
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.QueryDuplicator">
            <summary>
            Duplicate the query expression by making a copy with new table aliases
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.RedundantColumnRemover">
            <summary>
            Removes duplicate column declarations that refer to the same underlying column
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.RedundantJoinRemover">
            <summary>
            Removes joins expressions that are identical to joins that already exist
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.RedundantSubqueryRemover">
            <summary>
            Removes select expressions that don't add any additional semantic value
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ReferencedAliasGatherer">
            <summary>
             returns the set of all aliases produced by a query source
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.ReferencedColumnGatherer">
            <summary>
            Gathers all columns referenced by the given expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.RelationshipBinder">
            <summary>
            Translates accesses to relationship members into projections or joins
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.RelationshipIncluder">
            <summary>
            Adds relationship to query results depending on policy
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.SelectGatherer">
            <summary>
            returns the list of SelectExpressions accessible from the source expression
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.SingletonProjectionRewriter">
            <summary>
            Rewrites nested singleton projection into server-side joins
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.Data.Common.SkipToNestedOrderByRewriter" -->
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.Data.Common.SkipToRowNumberRewriter" -->
        <member name="T:IQToolkit.Data.Common.SubqueryRemover">
            <summary>
            Removes one or more SelectExpression's by rewriting the expression tree to not include them, promoting
            their from clause expressions and rewriting any column expressions that may have referenced them to now
            reference the underlying data directly.
            </summary>
        </member>
        <member name="T:IQToolkit.Data.Common.UnusedColumnRemover">
            <summary>
            Removes column declarations in SelectExpression's that are not referenced
            </summary>
        </member>
        <member name="T:IQToolkit.Data.EntityProvider">
            <summary>
            A LINQ IQueryable query provider that executes database queries over a DbConnection
            </summary>
        </member>
        <member name="M:IQToolkit.Data.EntityProvider.Execute(System.Linq.Expressions.Expression)">
            <summary>
            Execute the query expression (does translation, etc.)
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.Data.EntityProvider.GetExecutionPlan(System.Linq.Expressions.Expression)">
            <summary>
            Convert the query expression into an execution plan
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:IQToolkit.Query`1">
            <summary>
            A default implementation of IQueryable for use with QueryProvider
            </summary>
        </member>
        <member name="M:IQToolkit.Data.DbEntityProvider.Executor.GetCommand(IQToolkit.Data.Common.QueryCommand,System.Object[])">
            <summary>
            Get an ADO command object initialized with the command-text and parameters
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:IQToolkit.Data.DbEntityProvider.Executor.LogCommand(IQToolkit.Data.Common.QueryCommand,System.Object[])" -->
        <member name="T:IQToolkit.Data.Mapping.ImplicitMapping">
            <summary>
            A simple query mapping that attempts to infer mapping from naming conventions
            </summary>
        </member>
        <member name="T:IQToolkit.Data.TSqlLanguage">
            <summary>
            TSQL specific QueryLanguage
            </summary>
        </member>
        <member name="T:IQToolkit.IDeferLoadable">
            <summary>
            Common interface for controlling defer-loadable types
            </summary>
        </member>
        <member name="T:IQToolkit.DeferredList`1">
            <summary>
            A list implementation that is loaded the first time the contents are examined
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:IQToolkit.ExpressionReplacer">
            <summary>
            Replaces references to one specific instance of an expression node with another node
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.Grouping`2" -->
        <member name="T:IQToolkit.MostRecentlyUsedCache`1">
            <summary>
            Implements a cache over a most recently used list
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:IQToolkit.PartialEvaluator">
            <summary>
            Rewrites an expression tree so that locally isolatable sub-expressions are evaluated and converted into ConstantExpression nodes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:IQToolkit.PartialEvaluator.Eval(System.Linq.Expressions.Expression)" -->
        <!-- Badly formed XML comment ignored for member "M:IQToolkit.PartialEvaluator.Eval(System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Boolean})" -->
        <!-- Badly formed XML comment ignored for member "T:IQToolkit.PartialEvaluator.SubtreeEvaluator" -->
        <member name="T:IQToolkit.PartialEvaluator.Nominator">
            <summary>
            Performs bottom-up analysis to determine which nodes can possibly
            be part of an evaluated sub-tree.
            </summary>
        </member>
        <member name="T:IQToolkit.QueryCompiler">
            <summary>
            Creates a reusable, parameterized representation of a query that caches the execution plan
            </summary>
        </member>
        <member name="T:IQToolkit.StrongDelegate">
            <summary>
            Make a strongly-typed delegate to a weakly typed method (one that takes single object[] argument)
            (up to 8 arguments)
            </summary>
        </member>
        <member name="M:IQToolkit.StrongDelegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
            <summary>
            Create a strongly typed delegate over a method with a weak signature
            </summary>
            <param name="delegateType">The strongly typed delegate's type</param>
            <param name="target"></param>
            <param name="method">Any method that takes a single array of objects and returns an object.</param>
            <returns></returns>
        </member>
        <member name="M:IQToolkit.StrongDelegate.CreateDelegate(System.Type,System.Func{System.Object[],System.Object})">
            <summary>
            Create a strongly typed delegate over a Func delegate with weak signature
            </summary>
            <param name="delegateType"></param>
            <param name="fn"></param>
            <returns></returns>
        </member>
        <member name="T:IQToolkit.TypedSubtreeFinder">
            <summary>
            Finds the first sub-expression that is of a specified type
            </summary>
        </member>
        <member name="T:IQToolkit.TypeHelper">
            <summary>
            Type related helper methods
            </summary>
        </member>
        <member name="M:IQToolkit.Updatable.Insert``2(IQToolkit.IUpdatable{``0},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Insert an copy of the instance into the updatable collection and produce a result if the insert succeeds.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <typeparam name="S">The type of the result.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to insert.</param>
            <param name="resultSelector">The function that produces the result.</param>
            <returns>The value of the result if the insert succeed, otherwise null.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Insert``1(IQToolkit.IUpdatable{``0},``0)">
            <summary>
            Insert a copy of the instance into an updatable collection.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to insert.</param>
            <returns>The value 1 if the insert succeeds, otherwise 0.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Update``2(IQToolkit.IUpdatable{``0},``0,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Update the object in the updatable collection with the values in this instance only if the update check passes and produce
            a result based on the updated object if the update succeeds.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <typeparam name="S">The type of the result.</typeparam>
            <param name="collection">The updatable collection</param>
            <param name="instance">The instance to update.</param>
            <param name="updateCheck">A predicate testing the suitability of the object in the collection (often used that make sure assumptions have not changed.)</param>
            <param name="resultSelector">A function that produces a result based on the object in the collection after the update succeeds.</param>
            <returns>The value of the result function if the update succeeds, otherwise null.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Update``1(IQToolkit.IUpdatable{``0},``0,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Update the object in the updatable collection with the values in this instance only if the update check passes.
            </summary>
            <typeparam name="T">The type of the instance</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to update.</param>
            <param name="updateCheck">A predicate testing the suitability of the object in the collection.</param>
            <returns>The value 1 if the update succeeds, otherwise 0.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Update``1(IQToolkit.IUpdatable{``0},``0)">
            <summary>
            Update the object in the updatable collection with the values in this instance.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to update.</param>
            <returns>The value 1 if the update succeeds, otherwise 0.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.InsertOrUpdate``2(IQToolkit.IUpdatable{``0},``0,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Insert a copy of the instance if it does not exist in the collection or update the object in the collection with the values in this instance. 
            Produce a result based on the object in the collection after the insert or update succeeds.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <typeparam name="S">The type of the result.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to insert or update.</param>
            <param name="updateCheck">A predicate testing the suitablilty of the object in the collection if an update is required.</param>
            <param name="resultSelector">A function producing a result based on the object in the collection after the insert or update succeeds.</param>
            <returns>The value of the result if the insert or update succeeds, otherwise null.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.InsertOrUpdate``1(IQToolkit.IUpdatable{``0},``0,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Insert a copy of the instance if it does not exist in the collection or update the object in the collection with the values in this instance. 
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to insert or update.</param>
            <param name="updateCheck">A function producing a result based on the object in the collection after the insert or update succeeds.</param>
            <returns>The value 1 if the insert or update succeeds, otherwise 0.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.InsertOrUpdate``1(IQToolkit.IUpdatable{``0},``0)">
            <summary>
            Insert a copy of the instance if it does not exist in the collection or update the object in the collection with the values in this instance. 
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to insert or update.</param>
            <returns>The value 1 if the insert or update succeeds, otherwise 0.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Delete``1(IQToolkit.IUpdatable{``0},``0,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Delete the object in the collection that matches the instance only if the delete check passes.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to delete.</param>
            <param name="deleteCheck">A predicate testing the suitability of the corresponding object in the collection.</param>
            <returns>The value 1 if the delete succeeds, otherwise 0.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Delete``1(IQToolkit.IUpdatable{``0},``0)">
            <summary>
            Delete the object in the collection that matches the instance.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instance">The instance to delete.</param>
            <returns>The value 1 if the Delete succeeds, otherwise 0.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Delete``1(IQToolkit.IUpdatable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Delete all the objects in the collection that match the predicate.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="predicate">The predicate.</param>
            <returns>The number of objects deleted.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Batch``3(IQToolkit.IUpdatable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{IQToolkit.IUpdatable{``0},``1,``2}},System.Int32,System.Boolean)">
            <summary>
            Apply an Insert, Update, InsertOrUpdate or Delete operation over a set of items and produce a set of results per invocation.
            </summary>
            <typeparam name="T">The type of the instances.</typeparam>
            <typeparam name="S">The type of each result</typeparam>
            <typeparam name="U"></typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instances">The instances to apply the operation to.</param>
            <param name="fnOperation">The operation to apply.</param>
            <param name="batchSize">The maximum size of each batch.</param>
            <param name="stream">If true then execution is deferred until the resulting sequence is enumerated.</param>
            <returns>A sequence of results cooresponding to each invocation.</returns>
        </member>
        <member name="M:IQToolkit.Updatable.Batch``3(IQToolkit.IUpdatable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{IQToolkit.IUpdatable{``0},``1,``2}})">
            <summary>
            Apply an Insert, Update, InsertOrUpdate or Delete operation over a set of items and produce a set of result per invocation.
            </summary>
            <typeparam name="T">The type of the items.</typeparam>
            <typeparam name="S">The type of each result.</typeparam>
            <typeparam name="U"></typeparam>
            <param name="collection">The updatable collection.</param>
            <param name="instances">The instances to apply the operation to.</param>
            <param name="fnOperation">The operation to apply.</param>
            <returns>A sequence of results corresponding to each invocation.</returns>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ParamPos">
            <summary>
            Names or references a parameter expression.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.Morpher">
            <summary>
            Converts LINQ query operators to into custom expression's
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Query.OpenAccessEntityProvider.Execute(System.Linq.Expressions.Expression)">
            <summary>
            Execute the query expression (does translation, etc.)
            </summary>   
        </member>
        <member name="M:Telerik.OpenAccess.Query.OpenAccessQueryMapping.GetMappedMembers(IQToolkit.Data.Common.MappingEntity)">
            <summary>
            A sequence of all the mapped members
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Query.OpenAccessQueryMapping.IsAssociationRelationship(IQToolkit.Data.Common.MappingEntity,System.Reflection.MemberInfo)">
            <summary>
            Determines if the property is an assocation relationship.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Query.OpenAccessQueryMapping.GetEntity(System.Type)">
            <summary>
            Get the meta entity directly corresponding to the CLR type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Telerik.OpenAccess.Query.OpenAccessQueryPolice.Translate(System.Linq.Expressions.Expression)">
            <summary>
            Provides policy specific query translations.  This is where choices about inclusion of related objects and how
            heirarchies are materialized affect the definition of the queries.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Telerik.OpenAccess.Query.OpenAccessQueryExecutor.LogCommand(IQToolkit.Data.Common.QueryCommand,System.Object[])" -->
        <member name="T:Telerik.OpenAccess.Query.ResultData">
            <summary>
            Holds the query result data that the fixed result converters are working on.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ResultConverter">
            <summary>
            Provides a method to obtain the values of a specific type from the ResultData.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.RetrieveConverter">
            <summary>
            Retrieves a value from the aggregator
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.PropertyConverter">
            <summary>
            Sets a value to a property.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.FieldConverter">
            <summary>
            Sets a value to a field.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ObjectConstructor">
            <summary>
            Construct an instance by calling the ctor with the right amount of data.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.GroupKeyConstructor">
            <summary>
            Constructs a group key instance
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ObjectConstructorNoArgsInvoke">
            <summary>
            Construct an instance where a no-args constructor is to be used.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ObjectInitializer">
            <summary>
            Create an instance by calling the constructor and initializing the members.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ArrayConverter`1">
            <summary>
            Converts array elements to an array.
            </summary>
            <typeparam name="S">Array Element Type</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.BasicConverter`1">
            <summary>
            Obtain a strongly typed value from the result data.
            </summary>
            <typeparam name="S">Target type</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.NullableConverter`1">
            <summary>
            Obtain a strongly typed value from the result data.
            </summary>
            <typeparam name="S">Target type</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.EnumConverter`1">
            <summary>
            Obtain a strongly typed value from the result data.
            </summary>
            <typeparam name="S">Target type</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.TypeAsConverter`1">
            <summary>
            Obtain a strongly typed value from the result data.
            </summary>
            <typeparam name="S">Target type</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.PCRefConverter`1">
            <summary>
            Obtain a strongly typed PC value from the result data.
            </summary>
            <typeparam name="S">Target type, must be pc</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.ToStringConverter">
            <summary>
            Obtain a value and call ToString() on it.
            </summary>
        </member>
        <member name="T:Telerik.OpenAccess.Query.GroupingConverter`1">
            <summary>
            Obtain a grouping from the result data.
            </summary>
            <typeparam name="S">Target type</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.EnumerableConverter`1">
            <summary>
            Obtain a enumerable from the result data.
            </summary>
            <typeparam name="S">Target element type</typeparam>
        </member>
        <member name="T:Telerik.OpenAccess.Query.SubScalarRemover">
            <summary>
            Removes one or more SelectExpression's by rewriting the expression tree to not include them, promoting
            their from clause expressions and rewriting any column expressions that may have referenced them to now
            reference the underlying data directly.
            </summary>
        </member>
        <member name="M:Telerik.OpenAccess.Query.Translator.DescendJoin(Telerik.OpenAccess.Query.ChainedContext)">
            <summary>
            Figure out a join. The first argument has already been descended to and provides
            the scope and settings. The second argument is the right side of the join, and that
            expression needs to be descended to first before we build up further.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Telerik.OpenAccess.Query.TypedEnumerableWrapper`1">
            <summary>
            Creates a pure enumerable by wrapping another enumerable.
            </summary>
            <remarks>
            Using this class can avoid that the using code calls the Count property
            which happens when the enumerable is actually a collection or list.
            </remarks>
        </member>
    </members>
</doc>
